package services

import (
	"APIREST/models"
	"context"
	"errors"
	"fmt"
	"regexp"
	"strings"
)

var cveRegex = regexp.MustCompile(`^CVE-\d{4}-\d{4,}$`)

type vulnerabilityRepo interface {
	UpsertMany(ctx context.Context, vulns []models.Vulnerability) error
	Count(ctx context.Context) (int, error)
	Exists(ctx context.Context, cveID string) (bool, error)
	GetSummary(ctx context.Context) (models.SeveritySummary, error)
	GetUncorrectedSummary(ctx context.Context) (models.SeveritySummary, error)
}

type remediationRepo interface {
	UpsertByAsset(ctx context.Context, assetID string, cves []string) ([]string, error)
}

type VulnerabilityService struct {
	vulnRepo       vulnerabilityRepo
	remRepo        remediationRepo
	nvdClient      *NVDClient
	resultsPerPage int
	maxPages       int
}

func NewVulnerabilityService(
	vulnRepo vulnerabilityRepo,
	remRepo remediationRepo,
	nvdClient *NVDClient,
	resultsPerPage int,
	maxPages int,
) *VulnerabilityService {
	return &VulnerabilityService{
		vulnRepo:       vulnRepo,
		remRepo:        remRepo,
		nvdClient:      nvdClient,
		resultsPerPage: resultsPerPage,
		maxPages:       maxPages,
	}
}

func (s *VulnerabilityService) SyncVulnerabilities(ctx context.Context) (int, error) {
	totalStored := 0

	for page := 0; page < s.maxPages; page++ {
		startIndex := page * s.resultsPerPage
		vulns, err := s.nvdClient.FetchPage(ctx, startIndex, s.resultsPerPage)
		if err != nil {
			return totalStored, err
		}
		if len(vulns) == 0 {
			break
		}

		if err := s.vulnRepo.UpsertMany(ctx, vulns); err != nil {
			return totalStored, err
		}

		totalStored += len(vulns)
	}

	return totalStored, nil
}

func (s *VulnerabilityService) GetSummary(ctx context.Context) (models.SeveritySummary, error) {
	if err := s.ensureVulnerabilities(ctx); err != nil {
		return models.SeveritySummary{}, err
	}
	return s.vulnRepo.GetSummary(ctx)
}

func (s *VulnerabilityService) GetUncorrectedSummary(ctx context.Context) (models.SeveritySummary, error) {
	if err := s.ensureVulnerabilities(ctx); err != nil {
		return models.SeveritySummary{}, err
	}
	return s.vulnRepo.GetUncorrectedSummary(ctx)
}

func (s *VulnerabilityService) RegisterRemediations(ctx context.Context, assetID string, cves []string) ([]string, error) {
	cleanAssetID := strings.TrimSpace(assetID)
	if cleanAssetID == "" {
		return nil, errors.New("asset_id is required")
	}

	if len(cves) == 0 {
		return nil, errors.New("at least one cve is required")
	}

	validated := make([]string, 0, len(cves))
	for _, cve := range cves {
		cleanCVE := strings.ToUpper(strings.TrimSpace(cve))
		if !cveRegex.MatchString(cleanCVE) {
			return nil, fmt.Errorf("invalid cve format: %s", cve)
		}

		exists, err := s.vulnRepo.Exists(ctx, cleanCVE)
		if err != nil {
			return nil, err
		}

		if !exists {
			vuln, err := s.nvdClient.FetchByCVE(ctx, cleanCVE)
			if err != nil {
				return nil, err
			}
			if vuln == nil {
				return nil, fmt.Errorf("cve not found in nvd: %s", cleanCVE)
			}
			if err := s.vulnRepo.UpsertMany(ctx, []models.Vulnerability{*vuln}); err != nil {
				return nil, err
			}
		}

		validated = append(validated, cleanCVE)
	}

	return s.remRepo.UpsertByAsset(ctx, cleanAssetID, validated)
}

func (s *VulnerabilityService) ensureVulnerabilities(ctx context.Context) error {
	total, err := s.vulnRepo.Count(ctx)
	if err != nil {
		return err
	}
	if total > 0 {
		return nil
	}

	_, err = s.SyncVulnerabilities(ctx)
	return err
}
