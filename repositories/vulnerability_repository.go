package repositories

import (
	"APIREST/models"
	"context"
	"strings"

	"github.com/jackc/pgx/v5/pgxpool"
)

type VulnerabilityRepository struct {
	pool *pgxpool.Pool
}

func NewVulnerabilityRepository(pool *pgxpool.Pool) *VulnerabilityRepository {
	return &VulnerabilityRepository{pool: pool}
}

func (r *VulnerabilityRepository) UpsertMany(ctx context.Context, vulns []models.Vulnerability) error {
	if len(vulns) == 0 {
		return nil
	}

	tx, err := r.pool.Begin(ctx)
	if err != nil {
		return err
	}
	defer tx.Rollback(ctx)

	const query = `
INSERT INTO vulnerabilities (cve_id, severity, published_at, last_modified_at, source_identifier, updated_at)
VALUES ($1, $2, $3, $4, $5, NOW())
ON CONFLICT (cve_id) DO UPDATE SET
    severity = EXCLUDED.severity,
    published_at = EXCLUDED.published_at,
    last_modified_at = EXCLUDED.last_modified_at,
    source_identifier = EXCLUDED.source_identifier,
    updated_at = NOW()
`

	for _, vuln := range vulns {
		_, err = tx.Exec(
			ctx,
			query,
			vuln.CVEID,
			normalizeSeverity(vuln.Severity),
			vuln.PublishedAt,
			vuln.LastModifiedAt,
			vuln.SourceIdentifier,
		)
		if err != nil {
			return err
		}
	}

	return tx.Commit(ctx)
}

func (r *VulnerabilityRepository) Count(ctx context.Context) (int, error) {
	const query = `SELECT COUNT(*) FROM vulnerabilities`

	var total int
	err := r.pool.QueryRow(ctx, query).Scan(&total)
	return total, err
}

func (r *VulnerabilityRepository) Exists(ctx context.Context, cveID string) (bool, error) {
	const query = `SELECT EXISTS(SELECT 1 FROM vulnerabilities WHERE cve_id = $1)`

	var exists bool
	err := r.pool.QueryRow(ctx, query, strings.ToUpper(cveID)).Scan(&exists)
	return exists, err
}

func (r *VulnerabilityRepository) GetSummary(ctx context.Context) (models.SeveritySummary, error) {
	const query = `
SELECT severity, COUNT(*)
FROM vulnerabilities
GROUP BY severity
`

	rows, err := r.pool.Query(ctx, query)
	if err != nil {
		return models.SeveritySummary{}, err
	}
	defer rows.Close()

	return collectSummary(rows)
}

func (r *VulnerabilityRepository) GetUncorrectedSummary(ctx context.Context) (models.SeveritySummary, error) {
	const query = `
SELECT v.severity, COUNT(*)
FROM vulnerabilities v
LEFT JOIN (
    SELECT DISTINCT cve_id
    FROM asset_remediations
) rem ON rem.cve_id = v.cve_id
WHERE rem.cve_id IS NULL
GROUP BY v.severity
`

	rows, err := r.pool.Query(ctx, query)
	if err != nil {
		return models.SeveritySummary{}, err
	}
	defer rows.Close()

	return collectSummary(rows)
}

func normalizeSeverity(s string) string {
	switch strings.ToUpper(strings.TrimSpace(s)) {
	case "CRITICAL":
		return "CRITICAL"
	case "HIGH":
		return "HIGH"
	case "MEDIUM":
		return "MEDIUM"
	case "LOW":
		return "LOW"
	default:
		return "INFO"
	}
}

type summaryRows interface {
	Next() bool
	Scan(dest ...any) error
	Err() error
}

func collectSummary(rows summaryRows) (models.SeveritySummary, error) {
	summary := models.SeveritySummary{}

	for rows.Next() {
		var severity string
		var total int
		if err := rows.Scan(&severity, &total); err != nil {
			return models.SeveritySummary{}, err
		}

		switch strings.ToUpper(severity) {
		case "CRITICAL":
			summary.Critical = total
		case "HIGH":
			summary.High = total
		case "MEDIUM":
			summary.Medium = total
		case "LOW":
			summary.Low = total
		default:
			summary.Info = total
		}
	}

	if err := rows.Err(); err != nil {
		return models.SeveritySummary{}, err
	}
	return summary, nil
}
